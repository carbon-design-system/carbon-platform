# Logging service

## Service

The logging service provides a common logging mechanism for all packages and services.

It listens for messages from the message broker of type `EventMessage.log_logged` and transmits
these to the IBM Cloud LogDNA instance.

The logging service is the ingestion point for all important output generated by other services.
This includes all relevant FFDC (First Failure Data Capture) information.

The purpose of FFDC is to collect enough information during the first occurrence of an issue to
provide a fix without needing to reproduce the failure and perform additional debug of the problem.

## How to be a good logger!

_Here's a random assortment of things to think about when you're writing logs and traces in your
code._

- `Info` logs at the top of methods/functions could probably instead be covered by `@Trace()` or
  `withTrace` which would implicitly capture the args.

- `Info` logs are generally more useful in the middle-ish of methods/functions when you have more
  interesting data in-hand to log all at once.

- Generally, for small methods/functions, zero-to-one `info` log(s) is plenty.

- Removing useful, but noisy logs is almost never a good idea.

- If a single log statement in a function causes a ton of logs all on its own to the point where
  it's no longer useful, it often means the _code_ is too complex, not the logging. Consider
  factoring out relevant code into its own package or service entirely.

- If `A` calls `B` and it's nearly impossible for things to fail between those, only log in one of
  the two places.

- `Debug` logs can be used anywhere and it's okay for them to be somewhat noisy. This includes using
  them outside of `@Trace()` or `withTrace`-decorated functions.

- You can turn off debug logging by exporting `CARBON_DEBUG=false` prior to running your service.

- Regarding gSSP and gSP, the `proxy-server`'s request logger will provide a rough indication that
  gSSP will _eventually_ be called, so it's probably not super useful to have info logs in gSSP and
  gSP that log the arguments received.

- `Info`, `warn`, and `error` should almost always be past-tense (e.g "server is listening on port
  3000"). Though sometimes it's useful to have a "doing this thing" right before it actually
  happens, but typically that would be a `debug` log as opposed to an `info` log.

## Package APIs

The logging package is responsible for facilitating data transfer between services and the
`logging-service`.

In Standard run mode, it broadcasts messages to the messaging service.

In Dev mode, logs are written to stdout or stderr, depending on the log type.

### `Logging.isRemoteLoggingAllowed: boolean`

Sets the global setting for whether or not remote logging is allowed to be enabled. This supersedes
all environment-based switches and instance-based overrides. This is only really useful for testing
purpose and for the logging service itself, which uses Logger objects, but does not bother writing
them to the messaging infrastructure.

### `new Logging(config: LoggingConfig)`

Instantiates a `Logging` object with a given service and component name. All log messages given to
this logging instance will automatically include the component and optionally specified
[LoggingOptions](/packages/api/src/main/logging/logging.ts) in the appropriate part of the resulting
log entry.

Component strings can be anything that uniquely identifies an area of code, such as a class name,
file name, etc.

**Example**

```ts
const logging = new Logging({ component: 'RequestCache' })
```

**NOTE:** By default, the service name in the resulting logs will come from the
`CARBON_SERVICE_NAME` environment variable. This can be overridden by specifying a `service` in the
`LoggingConfig` object.

For all methods below, a "Loggable" object is defined as anything you'd typically expect to be able
to provide to `console.log`.

### `Logging#debug(message: Loggable): Promise<void>`

Logs a debugging message. This includes things like important function entry/exit, the size of a
list obtained from a remote source, the results after filtering an input set, etc.

> NOTE: Debug messaging is enabled in the Dev run mode and disabled in the Standard run mode. It is
> safe and acceptable to leave debug statements in code, where appropriate, unlike `console.log`
> statements, which would typically be removed from production code.

> NOTE: Debug logging can be turned on for a service running in Standard mode if `CARBON_DEBUG=true`
> is exported as an environment variables. This isn't typically needed, but can be useful for
> advanced debugging of production-running applications.

**Examples**

```ts
logging.debug(`Pre-filter list size: ${orig.length}, Post-filter list size: ${filtered.length}`)
```

```ts
function someImportantOperation(inputValue: string): boolean {
  await logging.debug(`-> someImportantOperation args: ${inputValue}`)

  // ...

  await logging.debug(`<- someImportantOperation returns: ${result}`)
  return result
}
```

### `Logging#info(message: Loggable): Promise<void>`

Logs an informational message. This is useful for point-in-time events, such as a service becoming
ready, a user account being created, a configuration setting being updated, a new data ingestion
endpoint becoming available, etc.

**Examples**

```ts
await logging.info(`Web server now listening on port ${port}`)
```

### `Logging#warn(message: string | Error): Promise<void>`

Logs a warning message. Warnings are typically unexpected situations, but do not represent a
breakdown of the core application logic. Examples include a user account becoming locked due to
failed login attempts, encountering an expected file that cannot be found or is blank, usages of
deprecated APIs, an operation taking longer than expected, etc.

**Examples**

```ts
await logging.warn(`Database collection ${collection.name} was empty. Recreating`)
```

### `Logging#error(message: string | Error): Promise<void>`

Logs an error message. Errors are unexpected situations and often represent a breakdown in core
logic. This often means entering the `catch` block of a `try/catch` statement. It can also mean
encountering `undefined` or `null` where values are expected to be present.

**Examples**

```ts
try {
  const dbConnection = db.connect()
  dbConnection.query('stuff')
} catch (err) {
  await logging.error('Could not connect to database')
  await logging.error(err)
}
```

```ts
error(`processImage encountered a checksum mismatch. Expected: ${expected}, Was: ${actual}`)
```

### Decorators and helpers

#### `@Trace()`

A decorator that automatically \[debug\] logs method entry and exit, along with the arguments and
return value of the method.

#### `withTrace()`

A higher-order decoration function similar to `@Trace()`, but for use outside of classes and/or in
JS instead of TS.

#### `safeStringify`

A utility function to safely convert any object to a string representation, covering all edge cases
of JS to prevent exceptions from being thrown in the process.

> Note: This utility function is only useful to core logging infrastructure which needs to accept
> and log any arbitrary input from other code. It should not be used for any other type of logging
> and is not required in order to log data via the `Logging` class.

#### `requestLogMiddleware`

An ExpressJS middleware which can be `use`d to provide logging for all requests coming through an
express server.
