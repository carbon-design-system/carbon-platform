# Services - logging

### Service

The logging service provides a common logging mechanism for all packages and services.

It listens for messages from the messaging service of type `EventMessage.LogLogged` and transmits
these to the IBM Cloud LogDNA instance.

The logging service is the ingestion point for all important output generated by other services.
This includes all relevant FFDC (First Failure Data Capture) information.

The purpose of FFDC is to collect enough information during the first occurrence of an issue to
provide a fix without needing to reproduce the failure and perform additional debug of the problem.

## Package APIs

The logging package is responsible for facilitating data transfer between services and the
`logging-service`.

In production mode, it broadcasts messages to the messaging service.

In development mode, logs are written to stdout or stderr, depending on the log type.

### `constructor(serviceName: string, component: string)`

Instantiates a `Logging` object with a given service and component name. All log messages given to
this logging instance will automatically include the service and component in the appropriate part
of the resulting log entry.

Component strings can be anything that uniquely identifies an area of code, such as a class name,
file name, etc.

**Example**

```ts
const logging = new Logging('web-app', 'request cache')
```

For all methods below, a "Loggable" object is defined as anything you'd typically expect to be able
to provide to `console.log`.

### `Logging#debug(message: Loggable)`

Logs a debugging message. This includes things like important function entry/exit, the size of a
list obtained from a remote source, the results after filtering an input set, etc.

> NOTE: Debug messaging is enabled in the DEV run mode and disabled in the PROD run mode.It is safe
> and acceptable to leave debug statements in code, where appropriate, unlike `console.log`
> statements, which would typically be removed from production code.

> NOTE: Debug logging can be turned on for a service running in PROD mode if `DEBUG=true` is
> exported as an environment variables. This isn't typically needed, but can be useful for advanced
> debugging of production-running applications.

**Examples**

```ts
logging.debug(`Pre-filter list size: ${orig.length}, Post-filter list size: ${filtered.length}`)
```

```ts
function someImportantOperation(inputValue: string): boolean {
  logging.debug(`-> someImportantOperation args: ${inputValue}`)

  // ...

  logging.debug(`<- someImportantOperation returns: ${result}`)
  return result
}
```

### `Logging#info(message: Loggable)`

Logs an informational message. This is useful for point-in-time events, such as a service becoming
ready, a user account being created, a configuration setting being updated, a new data ingestion
endpoint becoming available, etc.

**Examples**

```ts
logging.info(`Web server now listening on port ${port}`)
```

### `Logging#warn(message: string | Error)`

Logs a warning message. Warnings are typically unexpected situations, but do not represent a
breakdown of the core application logic. Examples include a user account becoming locked due to
failed login attempts, encountering an expected file that cannot be found or is blank, usages of
deprecated APIs, an operation taking longer than expected, etc.

**Examples**

```ts
logging.warn(`Database collection ${collection.name} was empty. Recreating`)
```

### `Logging#error(message: string | Error)`

Logs an error message. Errors are unexpected situations and often represent a breakdown in core
logic. This often means entering the `catch` block of a `try/catch` statement. It can also mean
encountering `undefined` or `null` where values are expected to be present.

**Examples**

```ts
try {
  const dbConnection = db.connect()
  dbConnection.query('stuff')
} catch (err) {
  logging.error('Could not connect to database')
  logging.error(err)
}
```

```ts
error(`processImage encountered a checksum mismatch. Expected: ${expected}, Was: ${actual}`)
```
